.. Documentation for the Cahn-Hilliard demo from DOLFIN.

.. _demos_cpp_pde_cahn_hilliard:

Cahn-Hilliard equation
======================

.. include:: ../common.txt

This text is C++ specific

UFL form file
-------------

The UFL code for this problem in two dimensions is
:download:`CahnHilliard2D.ufl`.

First, a mixed function spaces of linear Lagrange functions on triangles
is created:

.. code-block:: python

    P1 = FiniteElement("Lagrange", "triangle", 1)
    ME = P1*P1

On the mixed space, test and trial functions are defined:

.. code-block:: python

    q, v = TestFunctions(ME)
    du   = TrialFunction(ME)

The test functions have been split into components.

Coefficient functions are now defined for the current solution (the most recent
guess) and the solution from the beginning of the time step, and the functions
and split into components:

.. code-block:: python

    u   = Coefficient(ME)  # current solution
    u0  = Coefficient(ME)  # solution from previous converged step

    # Split mixed functions
    dc, dmu = split(du)
    c,  mu  = split(u)
    c0, mu0 = split(u0)

Various model parameters are defined as ``Constants``. This means that their
value can be changed without recompiling the UFL file.
Lastly, the value of :math:`\mu_{n+\theta}` is computed.

.. code-block:: python

    lmbda    = Constant(triangle) # surface energy parameter
    dt       = Constant(triangle) # time step
    theta    = Constant(triangle) # time stepping parameter

    # mu_(n+theta)
    mu_mid = (1-theta)*mu0 + theta*mu

To compute :math:`df/dc`, ``c`` is made a variable which will permit
differentiation with respect to it. The function :math:`f` is defined as
a function of :math:`c`, and then

.. code-block:: python

    # Compute the chemical potential df/dc
    c    = variable(c)
    f    = 100*c**2*(1-c)**2
    dfdc = diff(f, c)

The fully discrete variational problem is input, and the Jacobian of the
functional ``L`` which we we wish to drive to zero during the solution process
is computed using the directional derivative (``a``).

.. code-block:: python

    L0 = q*c*dx  - q*c0*dx   + dt*dot(grad(q), grad(mu_mid))*dx
    L1 = v*mu*dx - v*dfdc*dx - lmbda*dot(grad(v), grad(c))*dx
    L = L0 + L1

    a = derivative(L, u, du)

C++ code
--------

The first lines of this solver include the ``DOLFIN`` header files
and the two files generated by the form compiler, and the ``DOLFIN``
namespace is used:

.. code-block:: c++

  #include <dolfin.h>
  #include "CahnHilliard2D.h"
  #include "CahnHilliard3D.h"

  using namespace dolfin;


The class ``InitialConditions`` defines the initial conditions for the solver.
In the constructor the random number generator is seeded using the process
number so that different processes will generated different sequences when
running in parallel. The `eval` function evaluates the initial condition. The
first value (``[0]``) corresponds to :math:`c` and the second value (``[1]``)
corresponds to :math:`\mu`:

.. code-block:: c++

  // Initial conditions
  class InitialConditions : public Expression
  {
  public:

    InitialConditions(const Mesh& mesh) : Expression(mesh.topology().dim())
    {
      dolfin::seed(2 + dolfin::MPI::process_number());
    }

    void eval(Array<double>& values, const Data& data) const
    {
      values[0]= 0.63 + 0.02*(0.5 - dolfin::rand());
      values[1]= 0.0;
    }

  };

The next class is a subclass of ``NonlinearProblem``. A ``NonlinearProblem``
object can be passed to a ``NewtonSolver`` to be solved. The requirements
of a ``NonlinearProblem`` subclass are that it provides the function ``void
F(GenericVector& b, const GenericVector& x)`` for computing the residual
vector and the function ``void J(GenericMatrix& A, const GenericVector& x)``
for computing the Jacobian matrix.  The below class is designed to work for
both two different generated forms (2D and 3D), with the appropriate form
chosen based on the geometric dimension of the mesh. The makes the class
more complicated than would be the case if it supported single form type.
The class is first declared as a subclass on ``NonlinearProblem``:

.. code-block:: c++

  // User defined nonlinear problem
  class CahnHilliardEquation : public NonlinearProblem
  {
    public:

Its constructor takes the various arguments which are required
to create the forms:

.. code-block:: c++

      // Constructor
      CahnHilliardEquation(const Mesh& mesh, const Constant& dt,
                           const Constant& theta, const Constant& lambda)
                         : reset_Jacobian(true)
      {

If the mesh geometric dimension is two, dimension the a function space,
bilinear and linear forms associated with ``CahnHilliard2D`` are created.
Firstly, a shared pointer to a CahnHilliard2D::FunctionSpace is created,
and then two shared pointers ``_u`` and ``_u0`` and set to point to a
``Function`` from the space ``V``.  A shared pointer is used so that the
function space is not destroyed when the constructor is exited (the space will
not be destroyed until there are no more Functions or Forms that point to it).
Using the function space ``V``, bilinear and linear forms are created using ``new``,
and the coefficient functions are attached. These forms are then wrapped in a shared
pointer (using the ``reset`` function) which will take care of eventually destroying the
forms. Finally, ``_u`` is set equal to the initial condition (by interpolation).

.. code-block:: c++

        if (mesh.geometry().dim() == 2)
        {
          // Create function space and functions
          boost::shared_ptr<CahnHilliard2D::FunctionSpace> V(new CahnHilliard2D::FunctionSpace(mesh));
          _u.reset(new Function(V));
          _u0.reset(new Function(V));

          // Create forms and attach functions
          CahnHilliard2D::BilinearForm* _a = new CahnHilliard2D::BilinearForm(V, V);
          CahnHilliard2D::LinearForm*_L = new CahnHilliard2D::LinearForm(V);
          _a->u = *_u; _a->lmbda = lambda; _a->dt = dt; _a->theta = theta;
          _L->u = *_u; _L->u0 = *_u0;
          _L->lmbda = lambda; _L->dt = dt; _L->theta = theta;

          // Wrap pointers in a smart pointer
          a.reset(_a);
          L.reset(_L);

          // Set solution to intitial condition
          InitialConditions u_initial(mesh);
          *_u = u_initial;
        }

The same steps are followed in the case of a three-dimensional mesh:

.. code-block:: c++

        else if (mesh.geometry().dim() == 3)
        {
          // Create function space and functions
          boost::shared_ptr<CahnHilliard3D::FunctionSpace> V(new CahnHilliard3D::FunctionSpace(mesh));
          _u.reset(new Function(V));
          _u0.reset(new Function(V));

          // Create forms and attach functions
          CahnHilliard3D::BilinearForm* _a = new CahnHilliard3D::BilinearForm(V, V);
          CahnHilliard3D::LinearForm*_L = new CahnHilliard3D::LinearForm(V);
          _a->u = *_u; _a->lmbda = lambda; _a->dt = dt; _a->theta = theta;
          _L->u = *_u; _L->u0 = *_u0;
          _L->lmbda = lambda; _L->dt = dt; _L->theta = theta;

          // Wrap pointers in a smart pointer
          a.reset(_a);
          L.reset(_L);

          // Set solution to intitial condition
          InitialConditions u_initial(mesh);
          *_u = u_initial;
        }
        else
          error("Cahn-Hilliard model is programmed for 2D and 3D only");
      }

The function ``F`` computes the residual vector, which corresponds the assembly
of the form ``L``:

.. code-block:: c++

      // User defined residual vector
      void F(GenericVector& b, const GenericVector& x)
      {
        // Assemble RHS (Neumann boundary conditions)
        assemble(b, *L);
      }

The function ``J`` computes the Jacobian matrix, which corresponds the assembly
of the form ``a``. The variable ``reset_Jacobian``, which was set set equal to ``true''
in the constructor, instructs the assembler whether or not the sparse matrix
structure needs to be reset. Since the sparsity structure does not change for this
problem, ``reset_Jacobian`` is set to ``false`` after the first assembly operation.

.. code-block:: c++

      // User defined assemble of Jacobian
      void J(GenericMatrix& A, const GenericVector& x)
      {
        // Assemble system and RHS (Neumann boundary conditions)
        assemble(A, *a, reset_Jacobian);
        reset_Jacobian = false;
      }

The following two functions are helper functions which allow access to the
solution vectors:

.. code-block:: c++

      // Return solution function
      Function& u()
      { return *_u; }

      // Return solution function
      Function& u0()
      { return *_u0; }

The ``CahnHilliardEquation`` class stores data which is required for computing
the residual vector and the Jacobian matrix as private data:

.. code-block:: c++

    private:

      // Pointers to FunctionSpace and forms
      boost::scoped_ptr<Form> a;
      boost::scoped_ptr<Form> L;
      boost::scoped_ptr<Function> _u;
      boost::scoped_ptr<Function> _u0;
      bool reset_Jacobian;
  };

The main program is started, and declared such that it can accept command line
arguments, which are parsed to ``dolfin_init``:

.. code-block:: c++

  int main(int argc, char* argv[])
  {
    dolfin_init(argc, argv);


A mesh is then created with 96 vertices in each direction:

.. code-block:: c++

    // Mesh
    UnitSquare mesh(96, 96);

Constants which will be used in the assembling the forms and scalars that
will be used in the time stepping are declared:

.. code-block:: c++

    // Time stepping and model parameters
    Constant dt(5.0e-6);
    Constant theta(0.5);
    Constant lambda(1.0e-2);

    double t = 0.0;
    double T = 50*dt;

A ``CahnHilliardEquation`` object is created, which will be used in conjunction
with a Newton solver, and references to solution functions are
declared:

.. code-block:: c++

    // Create user-defined nonlinear problem
    CahnHilliardEquation cahn_hilliard(mesh, dt, theta, lambda);

    // Solution functions
    Function& u = cahn_hilliard.u();
    Function& u0 = cahn_hilliard.u0();


A Newton solver is created which will use a LU linear solver, and various
solver parameters are set:

.. code-block:: c++

    // Create nonlinear solver and set parameters
    NewtonSolver newton_solver("lu");
    newton_solver.parameters["convergence_criterion"] = "incremental";
    newton_solver.parameters["maximum_iterations"] = 10;
    newton_solver.parameters["relative_tolerance"] = 1e-6;
    newton_solver.parameters["absolute_tolerance"] = 1e-15;

A file is created for saving the solution at each time step in VTK format. The
data will be compressed to reduced the file size.

.. code-block:: c++

    // Save initial condition to file
    File file("cahn_hilliard.pvd", "compressed");
    file << u[0];

The solution process is advanced in time. At the beginning
of each time step the time in incremented and
:math:`u_{n} \leftarrow u_{n+1}`. The Newton solver is then used
to solve the nonlinear equation and the first component of
the solution (``u[0]``) is saved to a file, along with the
time ``t``.

.. code-block:: c++

    // Solve
    while (t < T)
    {
      // Update for next time step
      t += dt;
      u0.vector() = u.vector();

      // Solve
      newton_solver.solve(cahn_hilliard, u.vector());

      // Save function to file
      file << std::make_pair(&(u[0]), t);
    }

The final result is plotted to the screen and the program is finished.

.. code-block:: c++

    // Plot solution
    plot(u[0]);

    return 0;
  }


Complete code
-------------

.. literalinclude:: main.cpp
   :start-after: // Begin demo
   :language: c++

