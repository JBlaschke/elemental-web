"Documentation for all DOLFIN classes which are generated by Swig."

class Variable(object):
    """
    Common base class for DOLFIN variables.

    C++ includes: Variable.h 
    """
    def __init__(self, *args): 
        """
        __init__(self) -> Variable
        __init__(self, string name, string label) -> Variable

        Create variable with given name and label. 
        """
    def rename(self, *args):
        """
        rename(self, string name, string label)

        Rename variable. 
        """

    def name(self):
        """
        name(self) -> string

        Return name. 
        """

    def label(self):
        """
        label(self) -> string

        Return label (description). 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def disp(self):
        """
        .. warning::

            Deprecated, to be removed.
        """

    def __str__(self):
        """__str__(self) -> string"""

class Point(object):
    """
    A Point represents a point in R^3 with coordinates x, y, z, or,
    alternatively, a vector in R^3, supporting standard operations like
    the norm, distances, scalar and vector products etc.

    C++ includes: Point.h 
    """
    def __init__(self, *args): 
        """
        __init__(self, double x = 0.0, double y = 0.0, double z = 0.0) -> Point
        __init__(self, double x = 0.0, double y = 0.0) -> Point
        __init__(self, double x = 0.0) -> Point
        __init__(self) -> Point
        __init__(self, uint dim, double x) -> Point
        __init__(self, Point p) -> Point

        Copy constructor. 
        """
    def x(self):
        """
        x(self) -> double

        Return x-coordinate. 
        """

    def y(self):
        """
        y(self) -> double

        Return y-coordinate. 
        """

    def z(self):
        """
        z(self) -> double

        Return z-coordinate. 
        """

    def coordinates(self):
        """
        coordinates(self) -> double

        Return coordinate array. 
        """

    def __add__(self, *args):
        """__add__(self, Point p) -> Point"""

    def __sub__(self, *args):
        """__sub__(self, Point p) -> Point"""

    def __iadd__(self, *args):
        """__iadd__(self, Point p) -> Point"""

    def __isub__(self, *args):
        """__isub__(self, Point p) -> Point"""

    def __mul__(self, *args):
        """__mul__(self, double a) -> Point"""

    def __imul__(self, *args):
        """__imul__(self, double a) -> Point"""

    def __div__(self, *args):
        """__div__(self, double a) -> Point"""

    def __idiv__(self, *args):
        """__idiv__(self, double a) -> Point"""

    def distance(self, *args):
        """
        distance(self, Point p) -> double

        Compute distance to given point. 
        """

    def norm(self):
        """
        norm(self) -> double

        Compute norm of point representing a vector from the origin. 
        """

    def cross(self, *args):
        """
        cross(self, Point p) -> Point

        Compute cross product with given vector. 
        """

    def dot(self, *args):
        """
        dot(self, Point p) -> double

        Compute dot product with given vector. 
        """

    def str(self, *args):
        """
        str(self, bool verbose) -> string

        Return informal string representation (pretty-print). 
        """

    def __getitem__(self, *args):
        """__getitem__(self, int i) -> double"""

    def __setitem__(self, *args):
        """__setitem__(self, int i, double val)"""

class Mesh(Variable):
    """
    A Mesh consists of a set of connected and numbered mesh entities.

    Both the representation and the interface are dimension-independent,
    but a concrete interface is also provided for standard named mesh
    entities:

    .. tabularcolumns:: |c|c|c|

    +--------+-----------+-------------+
    | Entity | Dimension | Codimension |
    +========+===========+=============+
    | Vertex |  0        |             |
    +--------+-----------+-------------+
    | Edge   |  1        |             | 
    +--------+-----------+-------------+
    | Face   |  2        |             | 
    +--------+-----------+-------------+
    | Facet  |           |      1      |
    +--------+-----------+-------------+
    | Cell   |           |        0    |
    +--------+-----------+-------------+

    When working with mesh iterators, all entities and connectivity
    are precomputed automatically the first time an iterator is
    created over any given topological dimension or connectivity.

    Note that for efficiency, only entities of dimension zero
    (vertices) and entities of the maximal dimension (cells) exist
    when creating a Mesh. Other entities must be explicitly created
    by calling init().

    For example, all edges in a mesh may be created by a call to mesh.init(1).
    Similarly, connectivities such as all edges connected to a given vertex
    must also be explicitly created (in this case by a call to
    mesh.init(0, 1)).
    """
    def __init__(self, *args):
        """
        **Overloaded versions**

        * Mesh\ **()**

          Create empty mesh.

        * Mesh\ **(mesh)**

          Copy constructor.

          *Arguments*

          * mesh : :py:class:`Mesh`
                Some other mesh.

        * Mesh\ **(filename)**

          Create mesh from data file.

          *Arguments*

          * filename : string
                Name of file to load.
        """
    def num_vertices(self):
        """
        :returns: Number of vertices.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.num_vertices()
        9
        """

    def num_edges(self):
        """
        :returns: Number of edges.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.num_edges()
        0
        >>> mesh.init(1)
        16
        >>> mesh.num_edges()
        16
        """

    def num_faces(self):
        """
        :returns: Number of faces.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.num_faces()
        8
        """

    def num_facets(self):
        """
        :returns: Number of faces.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.num_facets()
        0
        >>> mesh.init(0,1)
        >>> mesh.num_facets()
        16
        """

    def num_cells(self):
        """
        :returns: Number of cells.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.num_cells()
        8
        """

    def num_entities(self, d):
        """
        :arg integer d: topological dimension
        :returns: Number of entities of topological dimension d.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.init(0,1)
        >>> mesh.num_entities(0)
        9
        >>> mesh.num_entities(1)
        16
        >>> mesh.num_entities(2)
        8
        """

    def size(self, d):
        """
        :arg integer d: topological dimension
        :returns: Number of entities of topological dimension d.
        :rtype: integer.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.init(0,1)
        >>> mesh.num_entities(0)
        9
        >>> mesh.num_entities(1)
        16
        >>> mesh.num_entities(2)
        8
        """

    def topology(self):
        """
        :returns: The topology object associated with the mesh.
        :rtype: :py:class:`MeshTopology`.
        """

    def geometry(self):
        """
        :returns: The geometry object associated with the mesh.
        :rtype: :py:class:`MeshGeometry`.
        """

    def intersection_operator(self):
        """
        :returns: The intersection operator object associated with the mesh.
        :rtype: :py:class:`IntersectionOperator`.
        """

    def data(self):
        """
        :returns: The mesh data object associated with the mesh.
        :rtype: :py:class:`MeshData`.
        """

    def type(self):
        """
        :returns: The cell type object associated with the mesh.
        :rtype: :py:class:`CellType`.
        """

    def init(self, *args):
        """
        Initialise mesh entities and connectivity.

        **Overloaded versions**

        * init\ **()**

          Compute all entities and connectivity.

        * init\ **(d)**

          Compute entities of given topological dimension.

          *Arguments*

          * d : integer
                topological dimension.

          *Returns*

              number of entities : *integer*

        * init\ **(d0, d1)**

          Compute connectivity between given pair of dimensions.

          *Arguments*

          * d0 : integer
                topological dimension.
          * d1 : integer
                topological dimension.
        """

    def clear(self):
        """
        Clear all mesh data. 
        """

    def order(self):
        """
        Order all mesh entities (not needed if "mesh order entities" is
        set). 
        """

    def ordered(self):
        """
        :returns: Return true iff topology is ordered according to the UFC
                  numbering.
        :rtype: bool.
        """

    def move(self, *args):
        """
        Move coordinates of Mesh.

        **Overloaded versions**

        * move\ **(boundary, method=hermite)**

          Move coordinates of mesh according to new boundary coordinates.

          *Arguments*

          * boundary : :py:class:`BoundaryMesh`
                New boundary coordinates.

          * method : :py:class:`ALEType`
                Method which defines how the coordinates should be moved, default
                is *hermite*.

        * move\ **(mesh, method=hermite)**

          Move coordinates of mesh according to adjacent mesh with common
          global vertices.

          *Arguments*

          * mesh : :py:class:`Mesh`
                New boundary coordinates.

          * method : :py:class:`ALEType`
                Method which defines how the coordinates should be moved,
                default is *hermite*.

        * move\ **(function)**

          Move coordinates of mesh according to displacement function. 

          *Arguments*

          * function : :py:class:`Function`
                Displacement function.
        """

    def smooth(self, num_iterations = 1):
        """
        Smooth internal vertices of mesh by local averaging.

        :arg integer num_iterations: Number of iterations to perform smoothing,
                                     default value is 1.
        """

    def smooth_boundary(self, num_iterations = 1, harmonic_smoothing = True):
        """
        Smooth boundary vertices of mesh by local averaging.

        :arg integer num_iterations: Number of iterations to perform smoothing,
                                     default value is 1.
        :arg bool harmonic_smoothing: Flag to turn on harmonics smoothing,
                                      default value is True.
        """

    def snap_boundary(self, sub_domain, harmonic_smoothing = True):
        """
        Snap boundary vertices of mesh to match given sub domain.

        :arg sub_domain: :py:class:`SubDomain`
        :arg bool harmonic_smoothing: Flag to turn on harmonics smoothing,
                                      default value is True.
        """

    def all_intersected_entities(self, *args):
        """
        This function computes the cell ids of all cells of the current mesh
        which intersects with a given mesh entity. The result is stored in
        the last argument to the function which might be a vector or a set
        depending on which version is called.

        **Overloaded versions**

        * all_intersected_entities\ **(point, ids_result)**

          Compute all ids of all cells which are intersected by the given
          point.

          *Arguments*

          * point : :py:class:`Point`
                Point to be checked for intersection with mesh.
          * ids_result : set of integers
              The cell ids which are intersected are stored in a set for
              efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(points, ids_result)**

          Compute all ids of all cells which are intersected by any point in
          points.

          *Arguments*

          * points : list of :py:class:`Point`
                Points to be checked for intersection with mesh.
          * ids_result : set of integers
                The cell ids which are intersected are stored in a set for
                efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(entity, ids_result)**

          Compute all ids of all cells which are intersected by the given
          entity.

          *Arguments*

          * entity : :py:class:`MeshEntity`
                Entity to be checked for intersection with mesh.
          * ids_result : list of integers
                The ids of the intersected cells are saved in a list. This is
                more efficent than using a set and allows a map between the
                (external) cell and the intersected cell of the mesh.

        * all_intersected_entities\ **(entities, ids_result)**

          Compute all id of all cells which are intersects by any entity in the
          list entities.

          *Arguments*

          * entities : list of :py:class:`MeshEntity`
                Entities to be checked for intersection with mesh.
          * ids_result : set of integers
                The cell ids which are intersected are stored in a set for
                efficiency reasons, to avoid to sort out duplicates later on.

        * all_intersected_entities\ **(another_mesh, ids_result)**

          Compute all ids of all cells which are intersected by another_mesh.

          *Arguments*

          * another_mesh : :py:class:`Mesh`
                Some other mesh to be checked for intersection with current mesh.
          * ids_result : set of integers
                The cell ids which are intersected are stored in a set for
                efficiency reasons, to avoid to sort out duplicates later on.
        """

    def any_intersected_entity(self, point):
        """
        :arg point: :py:class:`Point`
        :returns: The first id of the cell, which contains the point, returns
                  -1 if no cell is intersected.
        :rtype: integer.
        """

    def closest_point(self, point):
        """
        :arg point: :py:class:`Point`.
        :returns: The point inside the mesh which is closest to the point
                  query.
        :rtype: :py:class:`Point`.
        """

    def closest_cell(self, point):
        """
        :arg point: :py:class:`Point`.
        :returns: The index of the cell in the mesh which are closest to the
                  point query.
        :rtype: integer.
        """

    def closest_point_and_cell(self, point):
        """
        :arg point: :py:class:`Point`.
        :returns: The point inside the mesh and the corresponding cell index
                  which is closest to the point query.
        :rtype: ???.

        std::pair<(dolfin::Point,dolfin::uint)>

        .. warning::

            Incomplete documentation: Don't know what the return value translates into.
        """

    def hmin(self):
        """
        :returns: The minimum cell diameter.
        :rtype: float.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.hmin()
        0.70710678118654757
        """

    def hmax(self):
        """
        :returns: The maximum cell diameter.
        :rtype: float.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.hmax()
        0.70710678118654757
        """

    def str(self, verbose):
        """
        :arg bool verbose: Flag to turn on additional output.
        :returns: An informal string representation.
        :rtype: string.

        **Example**

        >>> mesh = dolfin.UnitSquare(2,2)
        >>> mesh.str(False)
        '<Mesh of topological dimension 2 (triangles) with 9 vertices and 8 cells, ordered>'
        """

    def coordinates(self):
        """
        :returns: Coordinates of all vertices.
        :rtype: numpy.ndarray.

        **Example**

        >>> mesh = dolfin.UnitSquare(1,1)
        >>> mesh.coordinates()
        array([[ 0.,  0.],
               [ 1.,  0.],
               [ 0.,  1.],
               [ 1.,  1.]])
        """

    def cells(self):
        """
        :returns: Connectivity for all cells.
        :rtype: numpy.ndarray.

        **Example**

        >>> mesh = dolfin.UnitSquare(1,1)
        >>> mesh.coordinates()
        array([[0, 1, 3],
               [0, 2, 3]])
        """

