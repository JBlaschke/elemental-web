#!/usr/bin/env python

"""This script generates the reST input for the Python Programmer's
Reference from the DOLFIN Python module."""

__author__ = "Kristian B. Oelgaard <k.b.oelgaard@gmail.com>"
__date__ = "2010-09-15"
__copyright__ = "Copyright (C) 2010 " + __author__
__license__  = "GNU GPL version 3 or any later version"

# Modified by Anders Logg, 2011
# Last changed: 2011-05-01

import os, sys, types

# List of modules to generate documentation for
modules = [dolfin, ffc, ufl]

# Import the dolfin and dolfindocstrings modules.
try:
    import dolfin
    import ffc
    import ufl
    from dolfin_utils.documentation import indent
except Exception as what:
    raise ImportError("Could not import the dolfin module \n  (error: %s),\n\
  update your PYTHONPATH variable?" % what)

not_define_all = []

class Module(object):
    def __init__(self, name, mod_file):
        self.name = name
        self.file = mod_file
        self.submodules = []
    def __hash__(self):
        return self.name

def get_modules(parent, loc, modules):
    for mod in os.listdir(loc):
        f = os.path.join(loc, mod)
        new_mod = None
        # Add modules (files) to global dict and to parent as submodules.
        if os.path.isfile(f):
            m, e = os.path.splitext(mod)
            if e == ".py" and m != "__init__":
                new_mod = Module(".".join([parent.name, m]), f)
                parent.submodules.append(m)
        # Add submodules (directories with '__init__.py' files) to global dict
        # and to parent as submodules.
        if os.path.isdir(f):
            if not "__init__.py" in os.listdir(f):
                continue
            new_mod = Module(".".join([parent.name, mod]), os.path.join(f, "__init__.py"))
            parent.submodules.append(mod)

            # Recursively extract submodules.
            get_modules(new_mod, f, modules)

        if new_mod is not None:
            if new_mod in modules:
                print new_mod, modules
                raise RuntimeError("module already present???")
            modules.append(new_mod)

def get_objects(module):
    """Extract classes and functions defined in a module.
    The function will not return imported classes and functions."""
    classes = []
    functions = []
    objects = {}

    # NOTE: Dirty hack for Python 2.6, in 2.7 it should be possible to use
    # importlib for submodules to test if __all__ is defined.
    define_all = False
    if "__all__" in open(module.file, "r").read():
        define_all = True
    else:
        not_define_all.append(module.file)

    # Get objects listed in __all__ by developer.
    exec("from %s import *" % module.name, objects)

    for key, val in objects.items():
#        print "key: ", key
        if isinstance(val, (types.ClassType, types.TypeType)):
            if define_all or module.name == val.__module__:
                classes.append(key)
        elif isinstance(val, types.FunctionType):
#            print "fun, mod: ", val.__module__
            if define_all or module.name == val.__module__:
                functions.append(key)
        # Anything else we need to catch?
        else:
            pass

    return classes, functions

def index_items(item_type, items):
    return """
%s:

.. toctree::
    :maxdepth: 1

%s
""" % (item_type, indent("\n".join(sorted(items)), 4))

def caption(string, level, top=False):
    markers = level*len(string)
    if top:
        return "%s\n%s\n%s\n" % (markers, string, markers)
    return "%s\n%s\n" % (string, markers)

def label(package_name, name):
    output = ".. _doc_%s_programmers_reference_" % package_name
    if package_name == "dolfin":
        output += "python_"
    return output + "%s:\n\n" % name

def write_object(package_name, directory, module_name, name, obj_type):
    output = ".. Documentation for the %s %s\n\n" % (obj_type, module_name + "." + name)
    output += label(package_name, "_".join(module_name.split(".")[1:] + [name.lower()]))
    output += name + "\n"
    output += "="*len(name) + "\n"
    output += "\n.. currentmodule:: %s\n\n" % module_name
    output += ".. auto%s:: %s\n" % (obj_type, name)
    outfile = os.path.join(directory, name + ".rst")
    f = open(outfile, "w")
    f.write(output)
    f.close()

def write_documentation(package_name, module):
    output_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)),\
                          os.pardir, "source", "doc", package_name, "programmers-reference")
    if package_name == "dolfin":
        output_dir = os.path.join(output_dir, "python")
    dirs = [output_dir]
    dirs += module.name.split(".")[1:]
    directory = os.path.sep.join(dirs)

    try:
        os.makedirs(directory)
    except:
        pass

    modules = []
    # Special handling of cpp module in dolfin.
    for sub in module.submodules:
        if sub == "cpp" and package_name == "dolfin":
            modules.append("cpp (Swig autogenerated module) <cpp/index>")
        else:
            modules.append(sub + "/index")

    classes, functions = get_objects(module)

    output = ".. Index file for the %s module.\n\n" % module.name
    output += label(package_name, "_".join(module.name.split(".")[1:] + ["index"]))

    if module.name == package_name and package_name == "dolfin":
        output += caption("Python programmer's reference", "#")
    elif module.name == package_name:
        output += caption("Programmer's reference", "#")
    else:
        header = "%s module" % module.name
        output += caption(header, "*")

    outfile = os.path.join(directory, "index.rst")
    f = open(outfile, "w")
    f.write(output)
    if modules:
        f.write(index_items("Modules", modules))
    if classes:
        f.write(index_items("Classes", classes))
    if functions:
        f.write(index_items("Functions", functions))

    f.write("""\nModule docstring:

.. automodule:: %s
  :no-members:
  :no-undoc-members:
  :no-show-inheritance:""" % module.name)
    f.close()

    for o in classes:
        write_object(package_name, directory, module.name, o, "class")

    for o in functions:
        write_object(package_name, directory, module.name, o, "function")

# Generate documentation for all modules
for mod in modules:
    print "\nWriting files for module: ", mod.__name__
    submods = [Module(mod.__name__, os.path.join(os.path.dirname(mod.__file__), "__init__.py"))]
    get_modules(submods[0], os.path.dirname(mod.__file__), submods)
    for submod in sorted(submods, key=lambda o: o.name):
#        if not submod[0] == "ffc.errorcontrol.errorcontrol":
#        if not submod[0] == "ffc.quadrature.symbolics":
#        if not submod[0] == "dolfin.compilemodules.compilemodule":
#        if not submod[0] == "dolfin.function.function":
#            continue
        print "  Writing files for sub module: ", submod.name
        write_documentation(mod.__name__, submod)

if not_define_all:
    print "\nThe following modules did not define the __all__ variable:"
    print "\n".join(["  " + m for m in not_define_all])

